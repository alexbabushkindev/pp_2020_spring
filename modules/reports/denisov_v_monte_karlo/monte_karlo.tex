\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}

% Устанавливаю поля, отступы между абзацами, отступы в списке
\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

% Мой стиль для листинга кода
\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

% Замена [1] -> 1. в списке литературы
\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

% Титульный лист
\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Вычисление многомерных интегралов методом Монте-Карло»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381706-1 \\ Денисов В. Л.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.
}

\vspace{\fill}

\begin{center} Нижний Новгород \\ 2020 \end{center}

\end{titlepage}
% Конец титульного листа

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Методами Монте-Карло называют численные методы решения математических задач при помощи моделирования случайных величин. При этом, решать методами Монте-Карло можно любые математические задачи, а не только задачи вероятностного происхождения, связанные со случайными величинами.
\par Важнейшим приемом построения методов Монте-Карло явлеяется сведение задачи к расчету математических ожиданий. Так как математические ожидания чаще всего представляют собой обычные интегралы, то центральное положение в теории метода Монте-Карло занимают методы вычисления интегралов.
\par Преимущества недетерминированных методов особенно ярко проявляются при решении задач большой размерности, когда применение традиционных детерминированных методов затруднено или совсем невозможно. 
\par Цель работы~--- изучение особенностей применения метода Монте-Карло в решении задач численного интегрирования с использованием различных технологий для выполнения параллельных вычислений.
\newpage
% Конец введения

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
В рамках лабораторной работы ставится задача разработки нескольких библиотек, реализующих алгоритм метода Монте-Карло для вычисления многомерных интегралов.
\par В итоге программный комплекс должен поддерживать:
\begin{itemize}
\item Последовательный алгоритм метода Монте-Карло;
\item Параллельный алгоритм метода Монте-Карло при помощи технологий OpenMP, TBB, std::threads;
\end{itemize}
\par Программное решение будет представлено следующим образом:
\begin{enumerate} 
\itemОтдельный модуль для каждой библиотеки, реализующей свою технологию.
\itemНабор автоматических тестов с использованием Google C++ Testing Framework для каждой из технологий.
\end{enumerate} 

\newpage
% Конец постановки задачи

% Метод решения
\section*{Метод решения}
\addcontentsline{toc}{section}{Метод решения}
Требуется вычислить определённый интеграл: \begin{equation}I = \int_{a}^{b}{f(x)dx}\end{equation}
\indent Воспользуемся неформальным геометрическим описанием интеграла и будем понимать его как площадь под графиком этой функции.
\par Для её нахождения существует следующий подход: отрезок разбивается на подотрезки, вычисляется площадь под графиком функции на каждом из них и складывается. Перейдем непосредственно к самому методу Монте-Карло.
\par Введем в рассмотрение случайную величину $u$, имеющую равномерное распределение на интервале интегрирования $(a;b)$ с плотностью $\varphi {(x)} = \frac{1}{b-a}$.
Тогда $f(u)$ будет тоже случайной величиной с математическим ожиданием: \begin{equation}M[f(u)]=\int_{a}^{b}{f(x) \varphi {(x)}dx} = \frac{1}{b-a}\int_{a}^{b}{f(x)}\end{equation}
\indent Таким образом искомый интеграл выражается как: \begin{equation}I = \int_{a}^{b}{f(x)dx} = (b-a)M[f(u)]\end{equation}
\indent Математическое ожидание случайной величины $f(u)$ можно легко оценить, смоделировав эту случайную величину и посчитав выборочное среднее.
\par Для этого выбираем $N$ случайных точек $u_{i}$, равномерно распределенных на интервале $(a;b)$. Затем для каждой точки $u_{i}$ вычисляем $f(u_{i})$. По найденным значениям вычисляем 
выборочное среднее $\frac{1}{N}\sum_{i=1}^{N}{f(u_{i})}$ и наконец, получаем оценку для интеграла: \begin{equation}\int_{a}^{b}{f(x)dx} \approx \frac{b-a}{N}\sum_{i=1}^{N}{f(u_{i})} \end{equation}
\indent Многомерный случай отличается лишь тем, что разделение на подотрезки будет происходить по каждой размерности, и, следовательно, формула примет вид:
\begin{equation}\int_{K}^{}{f(x_{1}...x_{k})dx} \approx \frac{\prod_{i=1}^{k}{(b_{i}-a_{i})}}{N}\sum_{i=1}^{N}{f(u_{i})} \end{equation}
\indent где K~--- многомерная область интегрирования размерности $k$.
\newpage
% Конец метода решения

% Схема распараллеливания
\section*{Схема распараллеливания}
\addcontentsline{toc}{section}{Схема распараллеливания}
Параллельные методы Монте-Карло существенным образом зависят от возможности генератора псевдослучайных чисел (ГПСЧ) создать достаточно много «хороших» последовательностей. Кроме того, должны выполняться следующие свойства:
\begin{itemize}
\item \emph{Независимость}: числа из различных последовательностей должны быть не коррелированны.
\item \emph{Масштабируемость}: нужно уметь генерировать столько последовательностей, сколько нужно для работы с большим числом потоков.
\item \emph{Локальность}: поток должен иметь возможность породить новую последовательность псевдослучайных чисел (ПСЧ) без взаимодействия с другими потоками.
\end{itemize}
\par В качестве подхода, который будет удовлетворять этим условиям, был выбран вариант с параметризацией. Рассмотрим его сущность подробнее.
\par Для генерации ПСЧ на разных потоках используются разные независимые случайные последовательности. Это реализуется путем использования одного и того же ГПСЧ, но с разными входными параметрами (параметризация). При этом нужно убедиться в том, что сгенерированные подобным образом последовательности будут независимыми. В общем случае этого гарантировать нельзя, все зависит от конкретной реализации ГПСЧ.
\par В рамках лабораторной работы в качестве ГПСЧ выбран \emph{mt19937( )}, который удовлетворяет всем перечисленным условиям. Он позволяет задать разные последовательности при помощи использования уникального \emph{seed} при их инициализации. Удовлетворяет условию некоррелированности, так как его период повторения $\rho = 2^{19937} - 1 \approx 10^{6001}$. Поддерживает создание нескольких экземпляров генератора в процессе работы, то есть каждому потоку свой.
\par Наконец, приведем общую схему работы алгоритма для параллельного случая. При инициализации каждого потока происходит создание отдельного экземпляра ГПСЧ,  при этом используется уникальное значение \emph{seed}. Поток выполняет вычисление значений функции над своей порцией входных данных (на своем подотрезке интегрирования). Мастер-поток собирает полученные результаты вместе и выполняет оставшиеся действия, не требующие параллельных вычислений.
\newpage
% Конец схемы распараллеливания

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Общая схема распраллеливания была описана в предыдущем разделе. Далее будут рассмотрены некоторые технические особенности для каждой из технологий.
\par Но перед этим заметим, что функции, реализующие параллельный вариант метода Монте-Карло при помощи различных технологий,  имеют единый вид для их вызова:
\begin{lstlisting}
double getIntegralMonteCarloPar(const std::function<double(const std::vector<double>&)>& func, const std::vector<double>& lowLimInt, const std::vector<double>& highLimInt, const unsigned int numberPoints, const int seed) { ... }
\end{lstlisting}
\par В качестве входных параметров передаются: интегрируемая функция, нижний и верхний пределы интегрирования, количество точек и стартовое значение для случайной генерации.

\subsection*{OpenMP}
\addcontentsline{toc}{subsection}{OpenMP}
Параллельные вычисления при использовании технологии OpenMP инициализируются с учетом того, что мастер-поток должен собрать полученные значения в общий результат. Для этого применяется редукция, которая объявляется директивой \verb|#pragma omp parallel reduction(+: result)|. 
\par Внутри секции, для которой произойдет редукция, уже выполнится разделение на потоки, поэтому именно здесь создаются экземпляры генератора ПСЧ. В качестве зерна передается значение стартовое значение из входных аргументов функции со сдвигом на номер потока: \emph{seed} + \verb|omp_get_thread_num()|.
\par Далее поток выполняет вычисление значений функции над своей порцией входных данных. Порции формируются из общего числа точек~--- применяется распараллеливание цикла при помощи \verb|#pragma omp for|.

\subsection*{TBB}
\addcontentsline{toc}{subsection}{TBB}
Как и в случае с OpenMP, библиотека TBB предоставляет специальный инструмент для выполнения редукции \verb|tbb::parallel_reduce(...)|.  Эта функция принимает ряд параметров. 
\par Первым парамтером является \verb|tbb::blocked_range| ~--- рекурсивно делимый полуинтервал с указанными границами $[0; N)$, где $N$~--- общее количество точек.
\par Во-вторых, начальное значение редукции равное нулю.
\par Затем лямбда, которая производит вычисления над переданной ей порцией данных. Разделение на порции происходит планировщиком TBB автоматически. Из-за этой особенности создание экземпляров генератора ПСЧ с уникальным \emph{seed} происходит за счет использования \verb|std::random_device| для получения параметра сдвига начального значения зерна.
\par Наконец, последним параметром является бинарный оператор редукции~--- в нашем случае суммирование~--- \verb|std::plus|.

\subsection*{std::threads}
\addcontentsline{toc}{subsection}{std::threads}
В случае использования std::threads первым делом выделяется память под объекты \verb|std::thread|, представляющие отдельные потоки. Затем производится вычисление объема порции данных, обрабатываемой каждым потоком путём взятия целой части от деления общего количества точек на количество потоков; остаток от деления добавляется к порции последнего потока.
\par В объект \verb|std::thread[i]|, представляющий \emph{i} поток, передаётся лямбда, а также необходимые значения, которые будут переданы в неё при запуске потока на выполнение. Лямбда принимает начало и конец подотрезка интегрирования для каждого потока, а также зерно для создания отдельного экземпляра генератора ПСЧ.
\par Затем каждый поток запускается на исполнение путем применения к объекту, представляющего его, метода \verb|join()|.
\par Редукция результатов, полученных каждым потоком, производится путем использования общей переменной. Доступ к ней защищён мьютексом для избегания "гонки данных".
\newpage
% Конец описания программной реализации

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности в программе представлен набор тестов, разработанных с помощью использования Google C++ Testing Framework.
\par Набор представляет из себя тесты, которые можно разделить на 2 связанных по смыслу блока: проверка корректности входных данных, а также проверка корректности вычислений.

\par К первому смысловому блоку относятся следующие тесты: 
\begin{itemize}
\item проверка используемого числа точек~--- должно быть положительным числом;
\item наличие значений в указанных пределах интегрирования~--- интервал интегрирования не может быть пустым;
\item проверка на эквивалентность размерностей пределов интегрирования~--- должны иметь одинаковую размерность.
\end{itemize}
 
\par Ко второму смысловому блоку относятся:
\begin{itemize}
\item вычисление интеграла для константной функции;
\item вычисление интеграла для функции одной переменной;
\item вычисление интеграла для функции двух переменных;
\item вычисление интеграла для функции трёх переменных;
\item сравнение результата вычислений параллельной версии с результатом, полученном при последовательном выполнении.
\end{itemize}

\par Успешное прохождение всех тестов доказывает корректность работы программного комплекса.

\newpage
% Конец подтверждения корректности


% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Вычислительные эксперименты для оценки эффективности параллельного варианта метода Монте-Карло для вычисления многомерных интегралов проводились на оборудовании со следующей аппаратной конфигурацией:

\begin{itemize}
\item Процессор: Intel Core i5-7200U, 2700 MHz, ядер: 2;
\item Оперативная память: 6012 МБ (DDR4 SDRAM), 2400 MHz;
\item ОС: Microsoft Windows 10 Home, версия 10.0.18363 сборка 18363.778.
\end{itemize}

\par Для проведения экспериментов по методу Монте-Карло производился выбор \verb|100 000 000| случайных точек. 
\par Результаты экспериментов представлены в Таблице 1.

\begin{table}[!h]
\caption{Резултаты вычислительных экспериментов}
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\multirow{3}{*}
	{\begin{tabular}[c]{@{}c@{}}Кол-во\\ потоков\end{tabular}} & 
\multirow{2}{*}
	{\begin{tabular}[c]{@{}c@{}}Последовательный\\ алгоритм\end{tabular}} & 
\multicolumn{6}{c|}
	{Параллельный алгоритм}	\\ 
	\cline{3-8} & & 
	\multicolumn{2}{c|}{OpenMP} & 
	\multicolumn{2}{c|}{TBB} & 
	\multicolumn{2}{c|}{std::threads} 
	\\ \cline{2-8}
	& t, с	    & t, с & speedup		& t, с & speedup		& t, с & speedup		\\ \hline
2   & 11.81     & 6.56 & 1.80       	& 6.45 & 1.83        	& 6.37 & 1.85           \\ \hline
4   & 11.81     & 5.01 & 2.36       	& 5.00 & 2.36         	& 5.04  & 2.34          \\ \hline
\end{tabular}
\end{table}

\par По данным, полученным в результате экспериментов, можно сделать вывод о том, что параллельный случай работает действительно быстрее, чем последовательный. Однако при увеличении числа потоков хотя бы до 4-х не наблюдается большого прироста скорости вычислений. Это объясняется ограничениями, которые возникают из-за характеристик оборудования~--- у процессора всего лишь 2 ядра.
\par В случае сравнения времени работы параллельного случая для каждой из технологий на 2-х потоках, можно сделать вывод, что эффективнее всех оказывается вариант с std::threads. Это объясняется тем, что в реализации алгоритма метода Монте-Карло явно указано, как следует разделить данные по потокам. Не очень сильно отстаёт TBB, так как эта технология имеет свой собственный менеджер памяти, позволяющий эффективно управлять данными. 

\newpage
% Конец результатов экспериментов


% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В результате лабораторной работы были разработаны несколько библиотек, реализующих метод Монте-Карло для вычисления многомерных интегрвалов.
\par Основной задачей данной лабораторной работы была реализация параллельной версии алгоритма при помощи использования различных технологий: OpenMP, TBB, std::threads. Эта задача была успешно достигнута, о чем говорят результаты экспериментов, проведенных в ходе работы. Они показывают, что параллельные варианты работают действительно быстрее, чем последовательный. Помимо этого, выполнено их сравнение друг с другом и сделаны соответствующие выводы в разделе "Результаты экспериментов".
\par Кроме того, были разработаны и доведены до успешного выполнения тесты, созданные для данного программного проекта с использованием Google C++ Testing Framework и необходимые для подтверждения корректности работы программы.

\newpage
% Конец заключения

% Список литературы
\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Список литературы}
\bibitem{Barkalov} Баркалов К.А. Методы параллельных вычислений. Н. Новгород: Изд-во Нижегородского госуниверситета им. Н.И. Лобачевского, 2011
\bibitem{Sobol} Соболь И.М. Численные методы Монте-Карло. - М.:Наука, 1973г.
\bibitem{Sysoev} Сысоев А.В., Мееров И.Б., Свистунов А.Н., Курылев А.Л., Сенин А.В., Шишков А.В., Корняков К.В., Сиднев А.А. «Параллельное программирование в системах с общей памятью. Инструментальная поддержка». Учебно-методические материалы по программе повышения квалификации «Технологии высокопроизводительных вычислений для обеспечения учебного процесса и научных исследований». Нижний Новгород, 2007, 110 с. 
\bibitem{Wiki1} Wikipedia: the free encyclopedia [Электронный ресурс] // URL: https://en.wikipedia.org/wiki/\verb|Mersenne_Twister| (дата обращения: 18.04.2020)
\bibitem{TBB} Intel® Threading Building Blocks Documentation [Электронный ресурс] // URL: https://software.intel.com/en-us/tbb-documentation (дата обращения: 19.04.2020)
\bibitem{stdthreads} Справочник по стандартной библиотеке C++ [Электронный ресурс] // URL: https://docs.microsoft.com/ru-ru/cpp/standard-library/thread-class (дата обращения: 19.04.2020)
\end{thebibliography}
\newpage
% Конец списка литературы

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
В данном разделе находится листинг всего кода, написанного в рамках лабораторной работы.

\lstinputlisting[language=C++]{../../../../modules/task_1/denisov_v_monte_karlo/monte_karlo.h}
\lstinputlisting[language=C++]{../../../../modules/task_1/denisov_v_monte_karlo/monte_karlo.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_1/denisov_v_monte_karlo/main.cpp}

\lstinputlisting[language=C++]{../../../../modules/task_2/denisov_v_monte_karlo/monte_karlo.h}
\lstinputlisting[language=C++]{../../../../modules/task_2/denisov_v_monte_karlo/monte_karlo.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_2/denisov_v_monte_karlo/main.cpp}

\lstinputlisting[language=C++]{../../../../modules/task_3/denisov_v_monte_karlo/monte_karlo.h}
\lstinputlisting[language=C++]{../../../../modules/task_3/denisov_v_monte_karlo/monte_karlo.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_3/denisov_v_monte_karlo/main.cpp}

\lstinputlisting[language=C++]{../../../../modules/task_4/denisov_v_monte_karlo/monte_karlo.h}
\lstinputlisting[language=C++]{../../../../modules/task_4/denisov_v_monte_karlo/monte_karlo.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_4/denisov_v_monte_karlo/main.cpp}

\end{document}